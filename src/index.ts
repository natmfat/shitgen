import { MockDatabase, MockColumn, MockTable } from "./MockDatabase";

import { Lexer } from "./Lexer";
import { Scanner } from "./Scanner";

import { sql } from "./DatabaseClient/client";

// @todo test (generation, scanner, lexer - basically each component)  with vitest

async function createDatabase(rawSql: string) {
  const lexer = new Lexer(rawSql);
  const tokens = lexer.getTokens();
  const scanner = new Scanner(tokens);
  const database = new MockDatabase();

  while (scanner.hasNextToken()) {
    const startPos = scanner.getPos();
    if (scanner.expectSequence(["CREATE", "TABLE", "IF", "NOT", "EXISTS"])) {
      const table = new MockTable(scanner.currentToken());
      database.addTable(table);
      scanner.nextToken(); // advance past table name
      if (scanner.expect("(")) {
        scanner.nextToken(); // advance past left paren

        // begin parsing table columns
        while (scanner.untilToken(";")) {
          const [columnName, columnType, ...typeModifiers] =
            scanner.getTokensUntil([",", [")", ";"]]);

          scanner.nextToken(); // advance past comma

          const typeScanner = new Scanner(typeModifiers);
          const isPrimaryKey = typeScanner.includesSequence(["PRIMARY", "KEY"]);
          const notNull = typeScanner.includesSequence(["NOT", "NULL"]);

          const column = new MockColumn(columnName, columnType);

          if (typeScanner.expect("REFERENCES")) {
            typeScanner.nextToken(); // advance past references
            const tableNameRef = typeScanner.currentToken();
            typeScanner.nextToken(); // advance beyond table name
            typeScanner.enforce("("); // automatically advances beyond ( after checking current token
            const tableColumnRef = typeScanner.currentToken();
            typeScanner.nextToken(); // advance beyond tableColumnRef
            typeScanner.enforce(")");
            column.link(tableNameRef, tableColumnRef);
          }

          column.modifierPrimaryKey = isPrimaryKey;
          column.modifierNotNull =
            notNull || isPrimaryKey || !!column.reference;

          table.addColumn(column);
        }

        // no need to skip ) or ; because the while loop will do it for us
      }
      const endPos = scanner.getPos();
      await sql.unsafe(tokens.slice(startPos, endPos).join(" "));
    }
    scanner.nextToken();
  }

  return database;
}

function generateTypeScript(database: MockDatabase) {
  for (const table of Object.values(database.tables)) {
    console.log(table.generateModelData());
    console.log(table.generateModelAutoGenerated());
    console.log(table.generateModelRelationship());
  }
}

async function main() {
  generateTypeScript(
    await createDatabase(`
  CREATE TABLE IF NOT EXISTS user_ (
    id INTEGER PRIMARY KEY,
    username TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL, 
    name TEXT,
    avatar_id INTEGER REFERENCES user_(id) ON DELETE CASCADE
  );
  
  CREATE TABLE IF NOT EXISTS avatar_ (
    id INTEGER PRIMARY KEY,
    src TEXT NOT NULL,
    alt TEXT
  );`)
  );

  process.exit(0);
}

main();
