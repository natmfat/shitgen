import { sql } from "./sql";
import { OneOf, Nullable, IsNotNullable } from "../types";
import { MockColumn, MockDatabase } from "../MockDatabase";
import assert from "assert";

// Relationships will have some of Data's keys, leading to another, different Data type
type BaseData = Record<string, unknown>;
type BaseRelationship<Data extends BaseData> = Partial<
  Record<keyof Data, BaseData>
>;

type SqlFragment = ReturnType<typeof sql>;

type NonNullValue<NonNull extends true | false, value> = NonNull extends true
  ? value
  : value | null;

// @todo order desc/asc

type WhereOperatorString<NonNull extends true | false> =
  | OneOf<{
      eq: NonNullValue<NonNull, string>;
      neq: NonNullValue<NonNull, string>;
      contains: string;
      endsWith: string;
      startsWith: string;
    }>
  | NonNullValue<NonNull, string>;

type WhereOperatorNumber<NonNull extends true | false> =
  | OneOf<{
      eq: NonNullValue<NonNull, number>;
      neq: NonNullValue<NonNull, number>;
      gt: number;
      lt: number;
      gte: number;
      lte: number;
      // @todo between?
    }>
  | NonNullValue<NonNull, number>;

type WhereOperatorBoolean<NonNull extends true | false> =
  | OneOf<{
      eq: NonNullValue<NonNull, boolean>;
      neq: NonNullValue<NonNull, boolean>;
    }>
  | NonNullValue<NonNull, boolean>;

// this "maps" a type of a value of Data to a the corresponding operators
// prettier-ignore
type WhereOperatorMap<Value> = NonNullable<Value> extends string
  ? WhereOperatorString<IsNotNullable<Value>>
  : NonNullable<Value> extends number
    ? WhereOperatorNumber<IsNotNullable<Value>>
    : NonNullable<Value> extends boolean
      ? WhereOperatorBoolean<IsNotNullable<Value>>
      : never;

type WhereOperator<
  Data extends BaseData,
  Relationship extends BaseRelationship<Data>
> = Partial<{
  [Key in keyof Data]: Partial<WhereOperatorMap<Data[Key]>>;
}> &
  Partial<{
    [Key in keyof Data]:
      | Partial<WhereOperatorMap<Data[Key]>>
      | (Key extends keyof Relationship
          ?
              | Data[Key]
              | Partial<{
                  [SubKey in keyof Relationship[Key]]: WhereOperatorMap<
                    Relationship[Key][SubKey]
                  >;
                }>
          : never);
  }>;

// @todo more than 1 relationship deep -> recursive types (use WhereOperator<value, value> if extends?)

type IncludeOperator<
  Data extends BaseData,
  Relationship extends BaseRelationship<Data>
> = Partial<{
  [Key in keyof Relationship]:
    | boolean
    | Partial<{
        [SubKey in keyof Relationship[Key]]: boolean;
      }>;
}>;

// prettier-ignore
type IncludeOperatorResult<
  Data extends BaseData,
  Relationship extends BaseRelationship<Data>,
  Include extends IncludeOperator<Data, Relationship>
> = {
  [Key in keyof Include]: Include[Key] extends boolean
    ? Key extends keyof Relationship
      ? Pick<Relationship, Key>
      : never
    : Include[Key] extends Partial<Record<infer SubKey, boolean>>
      ? Key extends keyof Relationship
        ? Pick<Relationship[Key], Extract<keyof Relationship[Key], SubKey>>
        : never
      : never;
};

// METHOD ARGUMENTS & RETURN TYPES

// DataArg is what's used in queries
// it excludes autogenerated keys & makes default values optional
// BaseData is UserData, no adjustments made
type DataArg<
  ModelData extends Record<string, unknown>,
  ModelAutoGenerated extends keyof ModelData,
  ModelOptional extends keyof ModelData
> = Omit<ModelData, ModelAutoGenerated | ModelOptional> &
  Partial<Pick<ModelData, ModelOptional>>;

export class Model<
  ModelData extends Record<string, unknown>,
  ModelAutoGenerated extends keyof ModelData,
  ModelOptional extends keyof ModelData,
  ModelRelationship extends BaseRelationship<ModelData>
> {
  constructor(private tableName: string, private database: MockDatabase) {}

  // @todo this should not exist, use mock db instead
  // private getTableFromId(key: string) {
  //   // return key.endsWith("id") ? key.substring(0, key.length - 2) : key;
  // }

  private createIdentifier(
    column: string,
    parentTable: string = this.tableName
  ) {
    // @todo wrap in sql()
    // will require rewriting generate where
    return `${parentTable}.${column}`;
  }

  private generateSelect(
    select: Array<keyof ModelData>,
    returning: boolean = false,
    parentTable: string = this.tableName,
    hasIncludeFragment: boolean = false
  ): SqlFragment {
    const columns =
      select.length > 0
        ? select.map((column) =>
            sql(this.createIdentifier(String(column), parentTable))
          )
        : hasIncludeFragment
        ? sql``
        : sql`*`;

    // @todo maybe use sql`${this.tableName}*` ??

    // @todo do not use * with include (pass include selects into here)

    return sql`${returning ? sql`RETURNING` : sql``} ${columns}`;
  }

  private emptyFragmentArray(fragment: SqlFragment[]) {
    return fragment.length === 0 ? sql`` : fragment;
  }

  private findReference(
    columnName: string,
    parentTable: string = this.tableName
  ) {
    const column = this.database
      .getTable(parentTable)
      .columns.find((column) => column.name === columnName);

    assert(
      column,
      `expected to find column "${columnName}" in table "${parentTable}"`
    );
    assert(
      column.reference,
      `expected column "${columnName}" in table "${parentTable}" to have a reference`
    );

    // @todo utility type: WellDefined?
    return column as MockColumn & {
      reference: NonNullable<MockColumn["reference"]>;
    };
  }

  private generateInclude(
    include: IncludeOperator<ModelData, ModelRelationship>
  ) {
    const joinFragment: SqlFragment[] = [];
    const selectFragment: SqlFragment[] = [];

    for (const [columnName, select] of Object.entries(include)) {
      const column = this.findReference(columnName);

      joinFragment.push(
        sql`JOIN ${sql(column.reference.tableName)} ON ${sql(
          this.createIdentifier(column.name)
        )} = ${sql(
          this.createIdentifier(
            column.reference.columnName,
            column.reference.tableName
          )
        )}`
      );
      if (typeof select !== "boolean") {
        selectFragment.push(
          this.generateSelect(
            Object.keys(select),
            false,
            column.reference.tableName
          )
        );
      }
    }

    return {
      joinFragment: joinFragment,
      selectFragment: selectFragment,
    };
  }

  private generateWhere<
    WhereData extends Record<string, unknown>,
    WhereRelationship extends BaseRelationship<WhereData>
  >(
    where: WhereOperator<WhereData, WhereRelationship>,
    parentTable: string = this.tableName,
    includeWhere: boolean = true
  ): string {
    // @todo very bad using unsafe (idk sql injections ok), fix that
    return `${includeWhere ? `WHERE` : ""} ${Object.entries(where)
      .map(([key, operators]) => {
        const selector = this.createIdentifier(key, parentTable);

        if (typeof operators === "undefined") {
          return;
        } else if (operators === null) {
          return `${selector} IS NULL`;
        } else if (operators && typeof operators === "object") {
          // @todo check if key is a relationship w/ mock db (if it is, then build where with diff parentTable!)
          // console.log(selector, operators);
          try {
            const column = this.findReference(key, parentTable);
            return this.generateWhere(
              operators as any,
              column.reference.tableName,
              false
            );
          } catch (error) {
            // no reference found, do nothing
            // @todo pass parameter before making reference checks? error handling like this seems kind of pythonic
          }

          // return this.generateWhere(operator as any, this.getTableFromId(key));
          // otherwise, it's an operator
          const [operator, targetValue] = Object.entries(operators)[0];
          switch (operator) {
            case "eq":
              return targetValue === null
                ? `${selector} IS NULL`
                : `${selector} = '${targetValue}'`;
            case "neq":
              return targetValue === null
                ? `${selector} IS NOT NULL`
                : `${selector} != '${targetValue}'`;
            case "contains":
              return `${selector} LIKE '%${targetValue}%'`;
            case "startsWith":
              return `${selector} LIKE '${targetValue}%'`;
            case "endsWith":
              return `${selector} LIKE '%${targetValue}'`;
            case "gt":
              return `${selector} > ${targetValue}`;
            case "lt":
              return `${selector} < ${targetValue}`;
            case "gte":
              return `${selector} >= ${targetValue}`;
            case "lte":
              return `${selector} >= ${targetValue}`;
          }
        }

        return `${selector} = '${operators}'`;
      })
      .join(" AND ")}`.trim();
  }

  async create({
    data,
  }: {
    data: DataArg<ModelData, ModelAutoGenerated, ModelOptional>;
  }) {
    return sql`
      INSERT INTO ${sql(this.tableName)} 
      ${sql(data as any, Object.keys(data))}`;
  }

  async find<T extends keyof ModelData>(args: {
    select?: Array<T>;
    where?: WhereOperator<ModelData, ModelRelationship>;
    include?: IncludeOperator<ModelData, ModelRelationship>;
  }) {
    const data = await this.findMany({ ...args, limit: 1 });
    return data.length > 0 ? data[0] : null;
  }

  async findMany<
    SelectKey extends keyof ModelData,
    ResolvedIncludeOperator extends IncludeOperator<
      ModelData,
      ModelRelationship
    >
  >({
    select = [],
    where = {},
    include = {} as ResolvedIncludeOperator,
    limit,
  }: {
    select?: Array<SelectKey>;
    where?: WhereOperator<ModelData, ModelRelationship>;
    include?: ResolvedIncludeOperator;
    limit?: number;
  }) {
    const { joinFragment, selectFragment } = this.generateInclude(include);
    // @todo generateSelect should accept and object instead to keep default values

    return sql<
      Array<
        Pick<ModelData, SelectKey> &
          IncludeOperatorResult<
            ModelData,
            ModelRelationship,
            ResolvedIncludeOperator
          >
      >
    >`
      SELECT ${this.generateSelect(
        select,
        false,
        this.tableName,
        selectFragment.length > 0
      )} ${this.emptyFragmentArray(selectFragment)} FROM ${sql(this.tableName)}
      ${this.emptyFragmentArray(joinFragment)}
      ${sql.unsafe(this.generateWhere(where))}
      ${limit ? sql`LIMIT ${limit}` : sql``}
    `;
  }

  async update<T extends keyof ModelData>({
    select = [],
    data,
    where,
  }: {
    select?: Array<T>;
    data: Partial<ModelData>;
    where: WhereOperator<ModelData, ModelRelationship>;
  }) {
    return sql`
      UPDATE ${sql(this.tableName)} SET ${sql(data as any, Object.keys(data))}
      ${sql.unsafe(this.generateWhere(where))}
      ${this.generateSelect(select, true)}
    `;
  }

  async delete({
    where,
  }: {
    where: WhereOperator<ModelData, ModelRelationship>;
  }) {
    return sql`
      DELETE FROM ${sql(this.tableName)} 
      ${sql.unsafe(this.generateWhere(where))}
    `;
  }
}
