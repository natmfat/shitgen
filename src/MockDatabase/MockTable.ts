import assert from "assert";
import { Nullable } from "../types";
import { MockColumn } from "./MockColumn";

const convertType = {
  TEXT: "string",
  INT: "number",
  INTEGER: "number",
  BIGINT: "number",
  FLOAT: "number",
  DOUBLE: "number",
  BOOL: "boolean",
  BOOLEAN: "boolean",
};

export class MockTable {
  name: string;
  columns: MockColumn[] = [];

  primaryKey: Nullable<MockColumn> = null;

  rawSql: Nullable<string> = null;

  constructor(name: string) {
    this.name = name;
  }

  addColumn(column: MockColumn) {
    assert(
      this.getColumn(column.name) === null,
      "cannot create columns with the same identifier"
    );
    this.columns.push(column);
  }

  getColumn(columnName: string) {
    return this.columns.find((column) => column.name === columnName) || null;
  }

  toString() {
    return `{${this.columns
      .map((column) => `"${column.name}": ${column.toString()}`)
      .join(",")}}`;
  }

  /**
   * user_ to User
   */
  private formatName(name = this.name) {
    return name
      .split("_")
      .map(
        (component) =>
          component.charAt(0).toUpperCase() + component.substring(1)
      )
      .join("");
  }

  private lowerCaseFirst(name: string) {
    return name.charAt(0).toLowerCase() + name.substring(1);
  }

  private withNull(type: string, notNull: boolean) {
    return notNull ? type : `${type} | null`;
  }

  private convertType(type: string) {
    const isArray = type.endsWith("[]");
    if (isArray) {
      type = type.substring(0, type.length - 2);
    }

    const convertedType =
      type in convertType
        ? convertType[type.toUpperCase() as keyof typeof convertType]
        : convertType["TEXT"];
    return isArray ? `Array<${convertedType}>` : convertedType;
  }

  // all methods prefixed by generate mean "outputs valid Typescript", unless private

  // @todo "exclude" method to use in select

  /**
   * Generate the TypeScript definition for data in a model
   * @returns Stringified TypeScript model data
   */
  generateModelData() {
    const modelData: string[] = [`type ${this.formatName()}Data = {`];
    for (const column of this.columns) {
      modelData.push(
        `  ${column.name}: ${this.withNull(
          this.convertType(column.type),
          column.modifierNotNull
        )};`
      );
    }
    modelData.push("}");
    return modelData.join("\n");
  }

  // @todo research if other types of keys can be autogenerated (or default)
  // @todo implement default

  private generateColumnType(criteria: keyof MockColumn): string {
    const columns = this.columns.filter((column) => column[criteria]);
    return columns.length === 0
      ? "never"
      : columns.map((column) => `"${column.name}"`).join("|");
  }

  /**
   * Generate the TypeScript definition for autogenerated columns (primary keys) in a model \
   * @returns List of autogenerated keys that need to be excluded from model data
   */
  generateModelAutoGenerated() {
    return `type ${this.formatName()}AutoGenerated = ${this.generateColumnType(
      "modifierPrimaryKey"
    )};`;
  }

  /**
   * Generate the TypeScript definition for optional columns (has a default value) \
   * @returns List of optional keys for model data
   */
  generateModelOptional() {
    return `type ${this.formatName()}Optional = ${this.generateColumnType(
      "modifierDefault"
    )};`;
  }

  /**
   * Generate TypeScript definition for columns linked to other tables
   * @returns Model relationship type
   */
  generateModelRelationship() {
    const modelRelationship: string[] = [
      `type ${this.formatName()}Relationship = {`,
    ];
    for (const column of this.columns) {
      // @todo validate that table exists
      if (column.reference) {
        modelRelationship.push(
          `  ${column.name}: ${this.formatName(
            column.reference.tableName
          )}Data;`
        );
      }
    }

    modelRelationship.push("}");
    return modelRelationship.join("\n");
  }

  generateModel() {
    return `export const ${this.lowerCaseFirst(
      this.formatName()
    )} = new Model<${this.formatName()}Data, ${this.formatName()}AutoGenerated, ${this.formatName()}Optional, ${this.formatName()}Relationship>("${
      this.name
    }");`;
  }
}
