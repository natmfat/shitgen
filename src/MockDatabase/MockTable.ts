import { Nullable } from "../types";
import { MockColumn } from "./MockColumn";

const convertType = {
  TEXT: "string",
  INT: "number",
  INTEGER: "number",
  BIGINT: "number",
  FLOAT: "number",
  DOUBLE: "number",
  BOOL: "boolean",
  BOOLEAN: "boolean",
};

export class MockTable {
  name: string;
  columns: MockColumn[] = [];

  primaryKey: Nullable<MockColumn> = null;

  constructor(name: string) {
    this.name = name;
  }

  addColumn(column: MockColumn) {
    this.columns.push(column);
  }

  getColumn(columnName: string) {
    return this.columns.find((column) => column.name === columnName);
  }

  /**
   * user_ to User
   */
  private formattedName(name = this.name) {
    return name
      .split("_")
      .map(
        (component) =>
          component.charAt(0).toUpperCase() + component.substring(1)
      )
      .join("");
  }

  private withNull(type: string, notNull: boolean) {
    return notNull ? type : `${type} | null`;
  }

  private convertType(type: string) {
    return type in convertType
      ? convertType[type as keyof typeof convertType]
      : convertType["TEXT"];
  }

  // all methods prefixed by generate mean "outputs valid Typescript", unless private

  // @todo "exclude" method to use in select
  /**
   * Generate a stringified array of each column name \
   * Useful in exported utilities
   * @returns Stringified string array (of column names)
   */
  generateColumns() {
    const columns = JSON.stringify(
      this.columns.map((column) => column.name),
      null,
      2
    );
    return `export const columns = ${columns};`;
  }

  /**
   * Generate the TypeScript definition for data in a model
   * @returns Stringified TypeScript model data
   */
  generateModelData() {
    const modelData: string[] = [`type ${this.formattedName()}Data = {`];
    for (const column of this.columns) {
      modelData.push(
        `  ${column.name}: ${this.withNull(
          this.convertType(column.type),
          column.modifierNotNull
        )};`
      );
    }
    modelData.push("}");
    return modelData.join("\n");
  }

  // @todo research if other types of keys can be autogenerated (or default)
  // @todo implement default
  // rename type to autogenerated -> autogenerated & optional

  /**
   * Generate the TypeScript definition for autogenerated columns (primary keys) in a model \
   * @returns List of autogenerated keys that need to be excluded from model data
   */
  generateModelAutoGenerated() {
    return `type ${this.formattedName()}AutoGenerated = ${this.columns
      .filter((column) => column.modifierPrimaryKey)
      .map((column) => `"${column.name}"`)
      .join("|")};`;
  }

  /**
   * Generate the TypeScript definition for optional columns (has a default value) \
   * @returns List of optional keys for model data
   */
  generateModelOptional() {
    return `type ${this.formattedName()}Optional = ${this.columns
      .filter((column) => column.modifierDefault)
      .map((column) => `"${column.name}"`)
      .join("|")};`;
  }

  /**
   * Generate TypeScript definition for columns linked to other tables
   * @returns Model relationship type
   */
  generateModelRelationship() {
    const modelRelationship: string[] = [
      `type ${this.formattedName()}Relationship = {`,
    ];
    for (const column of this.columns) {
      // @todo validate that table exists
      if (column.reference) {
        modelRelationship.push(
          `  ${column.name}: ${this.formattedName(
            column.reference.tableName
          )}Data;`
        );
      }
    }

    modelRelationship.push("}");
    return modelRelationship.join("\n");
  }

  generateModel() {
    return `
export class ${this.formattedName()}Model {
  static find() {
  }
}`;
  }
}
